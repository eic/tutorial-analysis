---
title: "The Reconstruction Output Tree"
teaching: 30
exercises: 0
questions:
- "How is the reconstruction output tree populated?"
objectives:
- "Become familiar with the tree branches"

keypoints:
- "Output trees contain a lot of information. Take time to explore what is available, identify what you want to try and do, find the relevant branches."
---
<!--
  Commenting out for now until the final content of this part of the lesson is decided. Leaning towards not including the locating factory/algorithm as a core part of the tutorial. - SJDK 29/03/24
- "Locate the EICrecon factory/algorithm used to fill a specific branch"
- "Become familiar with the edm4hep and edm4eic data models"
- "Understand associations and relations"
-->

What we generally call the simulation output are root trees generated by the reconstruction software, [EICrecon](https://github.com/eic/EICrecon/tree/main). The branches which appear in the output trees and their content are determined by which EICrecon factories and algorithms are run.

- Note, root 6.30.02 which is now used by eic-shell has some... backwards compatibility issues. If try to open file produced with root 6.30.02 in an older version of root, you're going to be in for a bad time. 
- If you're trying to open interactive windows such as a TBrowser via x-forwarding, it's likely to be very slow. You may wish to just copy the file to your local machine and open it there. 
  - The webviewer may also be quicker (although it's less usable and you will struggle to do more than just browsing the tree) - https://eic.phy.anl.gov/geoviewer/

## EICrecon Output Tree Structure

The output tree contains various branches appropriate for the individual detector subsystems. For example, the calorimeter subsystems will have branches for reconstructed hits and clusters. In addition to individual subsystem information, there are also branches for reconstructed quantities (e.g. reconstructed particles, inclusive kinematics, and jets) which may combine information from several subsystems. There are also branches encoding relationships between different reconstructed quantities as well as reconstructed and truth quantities. 


> Exercise
> - Stream a simulation output tree from within root (see previous lesson) and browse the structure by calling `new TBrowser()`
> - Take some time to explore the branches of the tree. What information is included for various subsystems? What are some of the reconstructed quantities?
> - Try plotting some basic quantities. Plot the cluster energy of the negative endcap ECal - do you see the peak from the scattered electron?
{: .challenge}

For the last part, some extra tips are included below.

## Browsing the file - ROOT Tips

We can navigate around the TBrowser and get it to draw quantities by simply double clicking them. However, sometimes the auto binning can be off or we might want to look at a specific range. We can do this to some extent directly from the TBrowser.

Alternatively, we can also plot variables to histograms of our own choosing on the fly. We can do this via -

```console
root $FILE
events->Draw("QUANTITY")
```
where $FILE is the file we want to open and "QUANTITY" is the thing we want to draw. For example -

```console
events->Draw("MCParticles.momentum.z")
```
will draw the MCParticles.momentum.z branch. So far, so much like just double clicking the TBrowser. However, we could define a new histogram and fill this variable to it -

```console
events->Draw("MCParticles.momentum.z>>h1(100,0,100)")
```
where h1 is our new histogram. This has 100 bins from 0 to 100. We can also apply selection criteria (i.e. cuts) on the fly. These do not need to be on the same variable we are drawing! For example -

```console
events->Draw("MCParticles.momentum.z>>h1(360,-60,300)", "MCParticles.charge<0")
```
will fill our histogram only with negatively charged particles. We can add more conditions if we want -

```console
events->Draw("MCParticles.momentum.z>>h1(360,-60,300)", "MCParticles.charge<0 && MCParticles.mass>1")
```
where we now also require that the particle mass is >1.

We can also add drawing options -

```console
events->Draw("MCParticles.momentum.z>>h1(360,-60,300)", "MCParticles.charge<0", "HISTERR")
```
such as adding error bars. We can also make 2D histograms in the same way -

```console
events->Draw("MCParticles.momentum.z:MCParticles.charge>>h2(40,-2,2, 360,-60,300)", "", "COLZ")
```
note the order of defining the binning. It's not what you might expect. Also, to interpret the result (as usual with 2D histograms), you might want to set a log Z scale -

```console
gPad->SetLogz()
```
<!---
Commenting out for now. I think associations and relations will be useful, but the other two seem to be more "advanced use cases" to me. Diving into the factories/algorithms seems to me more like something you would do if you were debugging an algorithm you had created, rather than just analysing existing output. - SJDK 29/03/24

## EICrecon Factories and Algorithms

## Data Models

## Associations and Relations

-->
